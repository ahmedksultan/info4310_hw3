<html>
    <head>
        <title>INFO 4310 - HW3</title>

        <script src="https://d3js.org/d3.v5.min.js"></script>
        <script src="https://d3js.org/topojson.v2.min.js"></script>

        <style>

            body { 
                background-color: #f0f0f0;
                justify-items: center;
            }

            h1, p {
                font-family: "Helvetica";
                text-align: center;
            }

            p {
                color: #1a1a1a;
            }

            h1 {
                color: #cf1d17;
                font-size: 72px;
                margin: 0;
                padding-top: 5vh;
            }

            text {
                font-family: "Helvetica";
            }

            .container {
                display: flex;
                align-items: flex-start;
                padding: 20px;
            }
            
        </style>
    </head>

    <body>
        <div class="header">
            <!-- tentative title idk -->
            <h1 class="page-title">foodfinder</h1>
            <p>by <b>Ahmed Sultan</b> (aks264) and <b>Sydney Wan</b> (ssw73), for Prof. Rzeszotarski's INFO 4310 class</p>
        </div>

        <!-- some stuff might go here -->

        <!-- using id to facilitate jumping btwn section -->
        <div id="neighborhood-select">
            <div class="container">
                <!-- bubble chart force graph w/ neighborhoods? -->
                <svg id="nbhd-bubbles" height="700" width="700" style="border: 1px solid blue;"></svg>

                <!-- minimap of boston -->
                <svg id="boston-minimap" height="400" width = "400" style="border: 1px solid red;"></svg>
            </div>
        </div>

        <div id="cuisine-select">
            <div class="container">
                <!-- bubble chart force graph w/ cuisines? -->
                <svg id="cuisine-bubbles" height="700" width="700" style="border: 1px solid blue;"></svg>

                <!-- minimap of neighborhood -->
                <svg id="nbhd-minimap" height="400" width = "400" style="border: 1px solid red;"></svg>
            </div>
        </div>

        <div id="restaurant-recs">
            <!-- lowkey just a list/list-like implementation -->
            
        </div>
    </body>

    <script>

        const requestData = async function() {

            const data = await d3.csv("data/yelp_boston.csv", d3.autoType);

            //Temporary data for the neighborhoods
            var neighborhoods = {};
            data.forEach( d => {
                var neighborhood = d['neighborhood'];
                var cuisines = JSON.parse(d.categories_json);
        
                if (neighborhood !== null) {
                    if (neighborhoods.hasOwnProperty(neighborhood)) {
                        neighborhoods[neighborhood]["count"] = neighborhoods[neighborhood]["count"] + 1;
                        
                        // COUNT THE NUMBER OF RESTAURANTS IN EACH NEIGHBORHOOD
                        cuisines.forEach( d => {
                            var name = d[0];
                            if(neighborhoods[neighborhood]["cuisines"].hasOwnProperty(name)) {
                                neighborhoods[neighborhood]["cuisines"][name] = neighborhoods[neighborhood]["cuisines"][name] + 1;
                            }
                            else { neighborhoods[neighborhood]["cuisines"][name] = 1; }
                        })
                    }
                    else {
                        var cuisine_map = [];
                        cuisines.forEach( d => {
                            var name = d[0];
                            cuisine_map[name] = 1;                          
                        })
                        neighborhoods[neighborhood] = {
                            'count': 1,
                            'cuisines': cuisine_map
                        };                       
                }
            }}); 
            var counts = [];
            Object.entries(neighborhoods).forEach(([key, value]) => {
                counts.push({'neighborhood': key, 'count': value.count, "cuisines": value.cuisines});
            });

            //Creating bubble chart
            const svg_nbhd_bubbles = d3.select("#nbhd-bubbles");
            const svg_cuisine_bubbles = d3.select("#cuisine-bubbles");
            const width = svg_nbhd_bubbles.attr("width");
            const height = svg_nbhd_bubbles.attr("height");

            const margin = { top: 5, bottom: 5, right: 5, left: 5 };
            const bubbleWidth = width - margin.left - margin.right;
            const bubbleHeight = height - margin.top - margin.bottom;

            const nbhd_colorScale = d3.scaleOrdinal().domain(Object.keys(neighborhoods)).range(d3.schemeSet3);

            createBubbleChart(svg_nbhd_bubbles, counts, "neighborhood", "count", nbhd_colorScale);
            
            //Create map of Boston

            //Let's get rid of the initial map data? but the second dataset also doesn't have all the neighborhoods
            //const mapData = await d3.json("data/boston_nbhds.json", d3.autoType);
            const mapData2 = await d3.json("data/BPDA_Neighborhood_Boundaries.geojson");
            console.log(mapData2);

            const svg_map = d3.select("#boston-minimap");
            const svg_nbhd_map = d3.select("#nbhd-minimap");
            const svg_map_W = svg_map.attr("width");
            const svg_map_H = svg_map.attr("height");
            let mapWidth = svg_map_W - margin.left - margin.right;
            let mapHeight = svg_map_H - margin.top - margin.bottom;
            let map = svg_map.append("g")
                            .attr("transform", "translate("+margin.left+","+margin.top+")");


            let projection = d3.geoMercator()
                                .fitSize([mapWidth, mapHeight], mapData2); 
            let path = d3.geoPath().projection(projection);

            map.selectAll("path.neighborhood").data(mapData2.features) 
                    .join("path")
                    .attr("class", "neighborhood")
                    .attr("id", d => d.properties.name.replace(/\s+/g, ''))
                    .attr("d", path)
                    .attr("stroke", "white") 
                    .attr("stroke-width", 0.5)
                    .attr("fill", "lightgray");

            function createBubbleChart(svg, data, name, value, colorScale) {
                const pack = d3.pack()
                            .size([bubbleWidth, bubbleHeight])
                            .padding(3);

                const hierarchy = d3.hierarchy({children: data})
                                .sum(d => d[value]);

                const root = pack(hierarchy);

                const bubbles = svg.append("g").selectAll()
                                                .data(root.leaves())
                                                .join("g")
                                                .attr("transform", d => `translate(${d.x},${d.y})`);
                
                bubbles.append("circle")
                        .attr("class", name)
                        .attr("r", d => d.r)
                        .attr("fill", d => colorScale(d.data[name]))
                        .on('mouseover', mouseEntersState)
                        .on('mouseout', mouseLeavesState)
                        .on("click", mouseClickEvent);

                //issue with hover over the words
                bubbles.append("text")
                        .attr("dy", "-0.3em")
                        .style("text-anchor", "middle")
                        .style("font-weight", 600)
                        .style("font-size", function(d) {
                            if (d.r < 30) { return 8; } //could probably dynamically program this to calculate font size
                            return 15;                  
                        })
                        .text(d => d.data[name])
                        //.call(wrap, 30); //how do i call this on only the small bubbles?

                bubbles.append("text")
                        .attr("dy", "1.2em")
                        .style("text-anchor", "middle")
                        .style("font-size", function(d) {
                            if (d.r < 30) { return 8; }
                            return 15;
                        })
                        .text(d => d.data[value]);
            }

            //will eventually display list of restaurants 
            function createRestaurantList() {

            }

            function mouseEntersState() {
                var bubble = d3.select(this);
                bubble.attr("opacity", 0.6);

                if (bubble.attr("class") === "neighborhood") {
                    var selected_nbhd = bubble._groups[0][0].__data__.data.neighborhood;
                    mapData2["features"].forEach(n => {
                        if (n.properties.name === selected_nbhd) {
                            selected_nbhd = selected_nbhd.replace(/\s+/g, '')
                            map.selectAll(`path#${selected_nbhd}`)
                                .attr("d", path)
                                .attr("fill", "#80b1d3");
                        }
                    });

                }
            }

            function mouseLeavesState() {
                var bubble = d3.select(this);
                bubble.attr("opacity", 1);

                if (bubble.attr("class") === "neighborhood") {
                    var selected_nbhd = bubble._groups[0][0].__data__.data.neighborhood;
                    mapData2["features"].forEach(n => {
                        if (n.properties.name === selected_nbhd) {
                            selected_nbhd = selected_nbhd.replace(/\s+/g, '')
                            map.selectAll(`path#${selected_nbhd}`)
                                .attr("d", path)
                                .attr("fill", "lightgray");
                        }
                    });

                }
            }

            function mouseClickEvent() {
                
                const selectedBubble = d3.select(this);

                const selected_nbhd = selectedBubble._groups[0][0].__data__.data.neighborhood;
                const nbhd_cuisines = selectedBubble._groups[0][0].__data__.data.cuisines;

                //If the bubble clicked was in the neighborhood bubble chart
                if (selectedBubble.attr("class") === "neighborhood") {
                    svg_cuisine_bubbles.html(""); //clears the bubble chart
                    svg_nbhd_map.html(""); //clears the bubble chart

                    document.getElementById("cuisine-select").scrollIntoView({behavior: "smooth"});
                    
                    //converting data into bubble chart flattened data
                    var cuisineCounts = [];
                    Object.entries(nbhd_cuisines).forEach(([key, value]) => {
                        cuisineCounts.push({'cuisine': key, 'restaurants': value});
                    });
                    
                    const cuisine_colorScale = d3.scaleOrdinal().domain(Object.keys(nbhd_cuisines)).range(d3.schemeSet3);

                    //call to create new bubble chart
                    createBubbleChart(svg_cuisine_bubbles, cuisineCounts, "cuisine", "restaurants", cuisine_colorScale);

                    //create map of individual neighborhood                    
                    var filtered_mapData2 = {...mapData2};
                    var nbhd_data = filtered_mapData2.features.filter(function(d){
                        return d.properties.name==selected_nbhd})

                    var nbhd_projection_data = filtered_mapData2;
                    nbhd_projection_data.features = nbhd_data;
    
                    let nbhd_map = svg_nbhd_map.append("g")
                            .attr("transform", "translate("+margin.left+","+margin.top+")");


                    let nbhd_projection = d3.geoMercator()
                                        .fitSize([mapWidth, mapHeight], nbhd_projection_data); 
                    let nbhd_path = d3.geoPath().projection(nbhd_projection);

                    nbhd_map.selectAll("path.minimap").data(nbhd_data) 
                    .join("path")
                    .attr("class", "minimap")
                    .attr("d", nbhd_path)
                    .attr("stroke", "white") 
                    .attr("stroke-width", 0.5)
                    .attr("fill", "lightgray");

                }

                //TO BE IMPLEMENTED -- DISPLAY RESTAURANT LIST

                // if (selectedBubble.attr("class") === "cuisines") {
                //     createRestaurantList();
                // }
            }

            //function courtesy of Mike Bostock: https://gist.github.com/mbostock/7555321
            function wrap(text, width) {
                text.each(function() {
                    var text = d3.select(this),
                        words = text.text().split(/\s+/).reverse(),
                        word,
                        line = [],
                        lineNumber = 0,
                        lineHeight = 0.7, // ems
                        y = text.attr("y"),
                        dy = parseFloat(text.attr("dy")),
                        tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
                    while (word = words.pop()) {
                    line.push(word);
                    tspan.text(line.join(" "));
                    if (tspan.node().getComputedTextLength() > width) {
                        line.pop();
                        tspan.text(line.join(" "));
                        line = [word];
                        tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                    }
                    }
            });

        }

        let neighborhood_counts = {}


        const data3 = await d3.json("data/bos_rest_formatted.json");

        data3.forEach( d => {
            d["loc_json"] = JSON.parse(d["loc_json"]);

            longitude=  d["loc_json"]["coordinate"]["longitude"];
            latitude = d["loc_json"]["coordinate"]["latitude"];

            var nbhd = nbhdChecker(longitude, latitude);

            d["neighborhood"] = nbhd;

            if (Object.keys(neighborhood_counts).includes(nbhd)) {
                if (nbhd == "CANNOTBEFOUND") {
                    console.log(d["name"] + " " + d["loc_json"]["display_address"][1]);
                }
                neighborhood_counts[nbhd] = neighborhood_counts[nbhd] + 1;
            } else {
                neighborhood_counts[nbhd] = 1;
            }
        });

        function nbhdChecker(lon, lat) {
            output = "CANNOTBEFOUND";

            mapData2["features"].forEach(n => {
                if (d3.geoContains(n, [lon, lat])) {
                    output = n["properties"]["name"];
                }
            });

            return output;
        }

        console.log(data3);

        console.log(neighborhood_counts);
        console.log(mapData2.features);
    }


        requestData();

    </script>
</html>